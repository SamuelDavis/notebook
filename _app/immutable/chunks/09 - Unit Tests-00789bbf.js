import{S as lt,i as st,s as it,k as o,q as n,a as r,l as a,m as f,r as u,h as t,c as p,b as i,E as l,B as ke}from"./index-a01aa152.js";function ot(tt){let v,le,K,c,k,se,ie,D,oe,ae,Y,fe,V,_,ne,M,d,ue,j,y,re,z,b,pe,G,E,me,J,w,R,ce,N,T,he,Q,I,ve,W,C,_e,X,L,de,Z,P,ye,$,x,be,g,S,Ee,ee,A,we,te,m,U,Te,Ie,F,Ce,Le,B,Pe,xe,O,Se,Ae,q,He;return{c(){v=o("h1"),le=n("The Three Laws of TDD"),K=r(),c=o("ol"),k=o("li"),se=n("You may not write production code until you’ve written a failing unit test."),ie=r(),D=o("li"),oe=n("You may not write more of a unit test than is sufficient to fail, and not compiling is failing."),ae=r(),Y=o("li"),fe=n("You may not write more production code than is sufficient to pass the currently failing test."),V=r(),_=o("h1"),ne=n("Keeping Tests Clean"),M=r(),d=o("p"),ue=n("Clean tests should not break when production code changes, unless those changes are broken."),j=r(),y=o("h1"),re=n("Tests Enable the -ilities"),z=r(),b=o("p"),pe=n("Clean tests protect against regressions."),G=r(),E=o("h1"),me=n("Clean Tests"),J=r(),w=o("ul"),R=o("li"),ce=n("Build, execute, assert"),N=r(),T=o("p"),he=n("Use as simple APIs as possible; build a suite of test helpers which extract away any complicated construction logic."),Q=r(),I=o("h1"),ve=n("A Dual Standard"),W=r(),C=o("p"),_e=n("Test environments may have less efficient helpers than production code."),X=r(),L=o("h1"),de=n("One Assert Per Test"),Z=r(),P=o("p"),ye=n("Avoid doing too much in a single test."),$=r(),x=o("h1"),be=n("Single Concept Per Test"),g=r(),S=o("p"),Ee=n("Trying to test multiple things (an entire user flow) in one test means edge cases will be missed."),ee=r(),A=o("h1"),we=n("F.I.R.S.T."),te=r(),m=o("ul"),U=o("li"),Te=n("Fast: fast enough that they can willingly be run regularly"),Ie=r(),F=o("li"),Ce=n("Independent: tests should be complete in themselves"),Le=r(),B=o("li"),Pe=n("Repeatable: if tests have external dependencies, then failures will be ambiguous"),xe=r(),O=o("li"),Se=n("Self-Validating: tests must clearly output success/failure"),Ae=r(),q=o("li"),He=n("Timely: tests should be written before production code")},l(e){v=a(e,"H1",{});var s=f(v);le=u(s,"The Three Laws of TDD"),s.forEach(t),K=p(e),c=a(e,"OL",{});var H=f(c);k=a(H,"LI",{});var De=f(k);se=u(De,"You may not write production code until you’ve written a failing unit test."),De.forEach(t),ie=p(H),D=a(H,"LI",{});var Ye=f(D);oe=u(Ye,"You may not write more of a unit test than is sufficient to fail, and not compiling is failing."),Ye.forEach(t),ae=p(H),Y=a(H,"LI",{});var Re=f(Y);fe=u(Re,"You may not write more production code than is sufficient to pass the currently failing test."),Re.forEach(t),H.forEach(t),V=p(e),_=a(e,"H1",{});var Ue=f(_);ne=u(Ue,"Keeping Tests Clean"),Ue.forEach(t),M=p(e),d=a(e,"P",{});var Fe=f(d);ue=u(Fe,"Clean tests should not break when production code changes, unless those changes are broken."),Fe.forEach(t),j=p(e),y=a(e,"H1",{});var Be=f(y);re=u(Be,"Tests Enable the -ilities"),Be.forEach(t),z=p(e),b=a(e,"P",{});var Oe=f(b);pe=u(Oe,"Clean tests protect against regressions."),Oe.forEach(t),G=p(e),E=a(e,"H1",{});var qe=f(E);me=u(qe,"Clean Tests"),qe.forEach(t),J=p(e),w=a(e,"UL",{});var Ke=f(w);R=a(Ke,"LI",{});var Ve=f(R);ce=u(Ve,"Build, execute, assert"),Ve.forEach(t),Ke.forEach(t),N=p(e),T=a(e,"P",{});var Me=f(T);he=u(Me,"Use as simple APIs as possible; build a suite of test helpers which extract away any complicated construction logic."),Me.forEach(t),Q=p(e),I=a(e,"H1",{});var je=f(I);ve=u(je,"A Dual Standard"),je.forEach(t),W=p(e),C=a(e,"P",{});var ze=f(C);_e=u(ze,"Test environments may have less efficient helpers than production code."),ze.forEach(t),X=p(e),L=a(e,"H1",{});var Ge=f(L);de=u(Ge,"One Assert Per Test"),Ge.forEach(t),Z=p(e),P=a(e,"P",{});var Je=f(P);ye=u(Je,"Avoid doing too much in a single test."),Je.forEach(t),$=p(e),x=a(e,"H1",{});var Ne=f(x);be=u(Ne,"Single Concept Per Test"),Ne.forEach(t),g=p(e),S=a(e,"P",{});var Qe=f(S);Ee=u(Qe,"Trying to test multiple things (an entire user flow) in one test means edge cases will be missed."),Qe.forEach(t),ee=p(e),A=a(e,"H1",{});var We=f(A);we=u(We,"F.I.R.S.T."),We.forEach(t),te=p(e),m=a(e,"UL",{});var h=f(m);U=a(h,"LI",{});var Xe=f(U);Te=u(Xe,"Fast: fast enough that they can willingly be run regularly"),Xe.forEach(t),Ie=p(h),F=a(h,"LI",{});var Ze=f(F);Ce=u(Ze,"Independent: tests should be complete in themselves"),Ze.forEach(t),Le=p(h),B=a(h,"LI",{});var $e=f(B);Pe=u($e,"Repeatable: if tests have external dependencies, then failures will be ambiguous"),$e.forEach(t),xe=p(h),O=a(h,"LI",{});var ge=f(O);Se=u(ge,"Self-Validating: tests must clearly output success/failure"),ge.forEach(t),Ae=p(h),q=a(h,"LI",{});var et=f(q);He=u(et,"Timely: tests should be written before production code"),et.forEach(t),h.forEach(t)},m(e,s){i(e,v,s),l(v,le),i(e,K,s),i(e,c,s),l(c,k),l(k,se),l(c,ie),l(c,D),l(D,oe),l(c,ae),l(c,Y),l(Y,fe),i(e,V,s),i(e,_,s),l(_,ne),i(e,M,s),i(e,d,s),l(d,ue),i(e,j,s),i(e,y,s),l(y,re),i(e,z,s),i(e,b,s),l(b,pe),i(e,G,s),i(e,E,s),l(E,me),i(e,J,s),i(e,w,s),l(w,R),l(R,ce),i(e,N,s),i(e,T,s),l(T,he),i(e,Q,s),i(e,I,s),l(I,ve),i(e,W,s),i(e,C,s),l(C,_e),i(e,X,s),i(e,L,s),l(L,de),i(e,Z,s),i(e,P,s),l(P,ye),i(e,$,s),i(e,x,s),l(x,be),i(e,g,s),i(e,S,s),l(S,Ee),i(e,ee,s),i(e,A,s),l(A,we),i(e,te,s),i(e,m,s),l(m,U),l(U,Te),l(m,Ie),l(m,F),l(F,Ce),l(m,Le),l(m,B),l(B,Pe),l(m,xe),l(m,O),l(O,Se),l(m,Ae),l(m,q),l(q,He)},p:ke,i:ke,o:ke,d(e){e&&t(v),e&&t(K),e&&t(c),e&&t(V),e&&t(_),e&&t(M),e&&t(d),e&&t(j),e&&t(y),e&&t(z),e&&t(b),e&&t(G),e&&t(E),e&&t(J),e&&t(w),e&&t(N),e&&t(T),e&&t(Q),e&&t(I),e&&t(W),e&&t(C),e&&t(X),e&&t(L),e&&t(Z),e&&t(P),e&&t($),e&&t(x),e&&t(g),e&&t(S),e&&t(ee),e&&t(A),e&&t(te),e&&t(m)}}}const ft={created_at:"2022-11-30 10:15:53 -0500",updated_at:"2022-12-05 09:41:47 -0500",tags:["programming:architecture","author:Robert C. Martin","book:Clean Code"]};class nt extends lt{constructor(v){super(),st(this,v,null,ot,it,{})}}export{nt as default,ft as metadata};
