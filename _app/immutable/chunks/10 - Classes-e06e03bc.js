import{S as yi,i as Ii,s as Pi,k as t,q as r,a as u,l as s,m as o,r as n,h as e,c,b as f,E as i,B as Be}from"./index-a01aa152.js";function Ci(Li){let h,Bl,cl,I,jl,ml,m,W,ql,Dl,Y,Vl,Wl,A,Yl,Al,G,Gl,vl,P,Jl,pl,E,J,Kl,Nl,K,Ql,_l,C,Tl,hl,w,Xl,El,S,Zl,bl,b,k,$l,N,Q,gl,le,T,ee,dl,x,ie,Ll,d,X,te,se,Z,oe,yl,M,ae,Il,v,$,fe,re,g,ne,ue,ll,ce,Pl,U,me,Cl,p,el,ve,pe,il,_e,he,tl,Ee,wl,H,be,Sl,R,de,kl,z,Le,xl,F,ye,Ml,_,O,Ie,sl,ol,Pe,Ce,al,we,Se,fl,ke,Ul,B,xe,Hl,L,j,Me,rl,nl,Ue,He,ul,Re;return{c(){h=t("h1"),Bl=r("Class Organization"),cl=u(),I=t("p"),jl=r("(Variables)"),ml=u(),m=t("ul"),W=t("li"),ql=r("Public Static"),Dl=u(),Y=t("li"),Vl=r("Private Static"),Wl=u(),A=t("li"),Yl=r("Public Instance"),Al=u(),G=t("li"),Gl=r("Private Instance"),vl=u(),P=t("p"),Jl=r("(Functions)"),pl=u(),E=t("ul"),J=t("li"),Kl=r("Public Method"),Nl=u(),K=t("li"),Ql=r("Private Method"),_l=u(),C=t("h1"),Tl=r("Encapsulation"),hl=u(),w=t("p"),Xl=r("You can make something protected for the sake of testing."),El=u(),S=t("h1"),Zl=r("Classes Should Be Small"),bl=u(),b=t("ul"),k=t("li"),$l=r("Class names describe responsibilities"),N=t("ul"),Q=t("li"),gl=r("if a name is too generic, the class is doing too much"),le=u(),T=t("li"),ee=r("classes should be able to be described briefly without words like if, and, or but"),dl=u(),x=t("h1"),ie=r("Single Responsibility Principle"),Ll=u(),d=t("ul"),X=t("li"),te=r("code should have one reason to change"),se=u(),Z=t("li"),oe=r("better many small, well-defined modules than a few massive, ambiguous modules"),yl=u(),M=t("p"),ae=r("Summary:"),Il=u(),v=t("ul"),$=t("li"),fe=r("many small classes"),re=u(),g=t("li"),ne=r("one responsibility per class"),ue=u(),ll=t("li"),ce=r("interop between classes to achieve complexity"),Pl=u(),U=t("h1"),me=r("Cohesion"),Cl=u(),p=t("ul"),el=t("li"),ve=r("small number of variables"),pe=u(),il=t("li"),_e=r("small number of functions"),he=u(),tl=t("li"),Ee=r("each function operates on as many functions as possible"),wl=u(),H=t("p"),be=r("Many variables with few methods operating on just some means another class should be created"),Sl=u(),R=t("h1"),de=r("Maintaining Cohesion Results in Many Small Classes"),kl=u(),z=t("p"),Le=r("When classes lose cohesion, split them"),xl=u(),F=t("h1"),ye=r("Organizing for Change"),Ml=u(),_=t("ul"),O=t("li"),Ie=r("any change to committed code introduces risk"),sl=t("ul"),ol=t("li"),Pe=r("retesting is necessitated"),Ce=u(),al=t("li"),we=r("fix design as soon as you’re having to change committed code"),Se=u(),fl=t("li"),ke=r("open-closed principle: open for extension, closed for modification"),Ul=u(),B=t("h1"),xe=r("Isolating From Change"),Hl=u(),L=t("ul"),j=t("li"),Me=r("rely on interfaces"),rl=t("ul"),nl=t("li"),Ue=r("allows for trivial mocking"),He=u(),ul=t("li"),Re=r("Dependency Inversion Principle: rely on abstractions")},l(l){h=s(l,"H1",{});var a=o(h);Bl=n(a,"Class Organization"),a.forEach(e),cl=c(l),I=s(l,"P",{});var je=o(I);jl=n(je,"(Variables)"),je.forEach(e),ml=c(l),m=s(l,"UL",{});var y=o(m);W=s(y,"LI",{});var qe=o(W);ql=n(qe,"Public Static"),qe.forEach(e),Dl=c(y),Y=s(y,"LI",{});var De=o(Y);Vl=n(De,"Private Static"),De.forEach(e),Wl=c(y),A=s(y,"LI",{});var Ve=o(A);Yl=n(Ve,"Public Instance"),Ve.forEach(e),Al=c(y),G=s(y,"LI",{});var We=o(G);Gl=n(We,"Private Instance"),We.forEach(e),y.forEach(e),vl=c(l),P=s(l,"P",{});var Ye=o(P);Jl=n(Ye,"(Functions)"),Ye.forEach(e),pl=c(l),E=s(l,"UL",{});var Rl=o(E);J=s(Rl,"LI",{});var Ae=o(J);Kl=n(Ae,"Public Method"),Ae.forEach(e),Nl=c(Rl),K=s(Rl,"LI",{});var Ge=o(K);Ql=n(Ge,"Private Method"),Ge.forEach(e),Rl.forEach(e),_l=c(l),C=s(l,"H1",{});var Je=o(C);Tl=n(Je,"Encapsulation"),Je.forEach(e),hl=c(l),w=s(l,"P",{});var Ke=o(w);Xl=n(Ke,"You can make something protected for the sake of testing."),Ke.forEach(e),El=c(l),S=s(l,"H1",{});var Ne=o(S);Zl=n(Ne,"Classes Should Be Small"),Ne.forEach(e),bl=c(l),b=s(l,"UL",{});var zl=o(b);k=s(zl,"LI",{});var ze=o(k);$l=n(ze,"Class names describe responsibilities"),N=s(ze,"UL",{});var Qe=o(N);Q=s(Qe,"LI",{});var Te=o(Q);gl=n(Te,"if a name is too generic, the class is doing too much"),Te.forEach(e),Qe.forEach(e),ze.forEach(e),le=c(zl),T=s(zl,"LI",{});var Xe=o(T);ee=n(Xe,"classes should be able to be described briefly without words like if, and, or but"),Xe.forEach(e),zl.forEach(e),dl=c(l),x=s(l,"H1",{});var Ze=o(x);ie=n(Ze,"Single Responsibility Principle"),Ze.forEach(e),Ll=c(l),d=s(l,"UL",{});var Fl=o(d);X=s(Fl,"LI",{});var $e=o(X);te=n($e,"code should have one reason to change"),$e.forEach(e),se=c(Fl),Z=s(Fl,"LI",{});var ge=o(Z);oe=n(ge,"better many small, well-defined modules than a few massive, ambiguous modules"),ge.forEach(e),Fl.forEach(e),yl=c(l),M=s(l,"P",{});var li=o(M);ae=n(li,"Summary:"),li.forEach(e),Il=c(l),v=s(l,"UL",{});var q=o(v);$=s(q,"LI",{});var ei=o($);fe=n(ei,"many small classes"),ei.forEach(e),re=c(q),g=s(q,"LI",{});var ii=o(g);ne=n(ii,"one responsibility per class"),ii.forEach(e),ue=c(q),ll=s(q,"LI",{});var ti=o(ll);ce=n(ti,"interop between classes to achieve complexity"),ti.forEach(e),q.forEach(e),Pl=c(l),U=s(l,"H1",{});var si=o(U);me=n(si,"Cohesion"),si.forEach(e),Cl=c(l),p=s(l,"UL",{});var D=o(p);el=s(D,"LI",{});var oi=o(el);ve=n(oi,"small number of variables"),oi.forEach(e),pe=c(D),il=s(D,"LI",{});var ai=o(il);_e=n(ai,"small number of functions"),ai.forEach(e),he=c(D),tl=s(D,"LI",{});var fi=o(tl);Ee=n(fi,"each function operates on as many functions as possible"),fi.forEach(e),D.forEach(e),wl=c(l),H=s(l,"P",{});var ri=o(H);be=n(ri,"Many variables with few methods operating on just some means another class should be created"),ri.forEach(e),Sl=c(l),R=s(l,"H1",{});var ni=o(R);de=n(ni,"Maintaining Cohesion Results in Many Small Classes"),ni.forEach(e),kl=c(l),z=s(l,"P",{});var ui=o(z);Le=n(ui,"When classes lose cohesion, split them"),ui.forEach(e),xl=c(l),F=s(l,"H1",{});var ci=o(F);ye=n(ci,"Organizing for Change"),ci.forEach(e),Ml=c(l),_=s(l,"UL",{});var V=o(_);O=s(V,"LI",{});var Fe=o(O);Ie=n(Fe,"any change to committed code introduces risk"),sl=s(Fe,"UL",{});var mi=o(sl);ol=s(mi,"LI",{});var vi=o(ol);Pe=n(vi,"retesting is necessitated"),vi.forEach(e),mi.forEach(e),Fe.forEach(e),Ce=c(V),al=s(V,"LI",{});var pi=o(al);we=n(pi,"fix design as soon as you’re having to change committed code"),pi.forEach(e),Se=c(V),fl=s(V,"LI",{});var _i=o(fl);ke=n(_i,"open-closed principle: open for extension, closed for modification"),_i.forEach(e),V.forEach(e),Ul=c(l),B=s(l,"H1",{});var hi=o(B);xe=n(hi,"Isolating From Change"),hi.forEach(e),Hl=c(l),L=s(l,"UL",{});var Ol=o(L);j=s(Ol,"LI",{});var Oe=o(j);Me=n(Oe,"rely on interfaces"),rl=s(Oe,"UL",{});var Ei=o(rl);nl=s(Ei,"LI",{});var bi=o(nl);Ue=n(bi,"allows for trivial mocking"),bi.forEach(e),Ei.forEach(e),Oe.forEach(e),He=c(Ol),ul=s(Ol,"LI",{});var di=o(ul);Re=n(di,"Dependency Inversion Principle: rely on abstractions"),di.forEach(e),Ol.forEach(e)},m(l,a){f(l,h,a),i(h,Bl),f(l,cl,a),f(l,I,a),i(I,jl),f(l,ml,a),f(l,m,a),i(m,W),i(W,ql),i(m,Dl),i(m,Y),i(Y,Vl),i(m,Wl),i(m,A),i(A,Yl),i(m,Al),i(m,G),i(G,Gl),f(l,vl,a),f(l,P,a),i(P,Jl),f(l,pl,a),f(l,E,a),i(E,J),i(J,Kl),i(E,Nl),i(E,K),i(K,Ql),f(l,_l,a),f(l,C,a),i(C,Tl),f(l,hl,a),f(l,w,a),i(w,Xl),f(l,El,a),f(l,S,a),i(S,Zl),f(l,bl,a),f(l,b,a),i(b,k),i(k,$l),i(k,N),i(N,Q),i(Q,gl),i(b,le),i(b,T),i(T,ee),f(l,dl,a),f(l,x,a),i(x,ie),f(l,Ll,a),f(l,d,a),i(d,X),i(X,te),i(d,se),i(d,Z),i(Z,oe),f(l,yl,a),f(l,M,a),i(M,ae),f(l,Il,a),f(l,v,a),i(v,$),i($,fe),i(v,re),i(v,g),i(g,ne),i(v,ue),i(v,ll),i(ll,ce),f(l,Pl,a),f(l,U,a),i(U,me),f(l,Cl,a),f(l,p,a),i(p,el),i(el,ve),i(p,pe),i(p,il),i(il,_e),i(p,he),i(p,tl),i(tl,Ee),f(l,wl,a),f(l,H,a),i(H,be),f(l,Sl,a),f(l,R,a),i(R,de),f(l,kl,a),f(l,z,a),i(z,Le),f(l,xl,a),f(l,F,a),i(F,ye),f(l,Ml,a),f(l,_,a),i(_,O),i(O,Ie),i(O,sl),i(sl,ol),i(ol,Pe),i(_,Ce),i(_,al),i(al,we),i(_,Se),i(_,fl),i(fl,ke),f(l,Ul,a),f(l,B,a),i(B,xe),f(l,Hl,a),f(l,L,a),i(L,j),i(j,Me),i(j,rl),i(rl,nl),i(nl,Ue),i(L,He),i(L,ul),i(ul,Re)},p:Be,i:Be,o:Be,d(l){l&&e(h),l&&e(cl),l&&e(I),l&&e(ml),l&&e(m),l&&e(vl),l&&e(P),l&&e(pl),l&&e(E),l&&e(_l),l&&e(C),l&&e(hl),l&&e(w),l&&e(El),l&&e(S),l&&e(bl),l&&e(b),l&&e(dl),l&&e(x),l&&e(Ll),l&&e(d),l&&e(yl),l&&e(M),l&&e(Il),l&&e(v),l&&e(Pl),l&&e(U),l&&e(Cl),l&&e(p),l&&e(wl),l&&e(H),l&&e(Sl),l&&e(R),l&&e(kl),l&&e(z),l&&e(xl),l&&e(F),l&&e(Ml),l&&e(_),l&&e(Ul),l&&e(B),l&&e(Hl),l&&e(L)}}}const Si={created_at:"2022-12-05 11:45:16 -0500",updated_at:"2022-12-06 21:21:42 -0500",tags:["programming:architecture","author:Robert C. Martin","book:Clean Code"]};class ki extends yi{constructor(h){super(),Ii(this,h,null,Ci,Pi,{})}}export{ki as default,Si as metadata};
