import{S as Oe,i as Ge,s as Ke,k as o,q as r,a as p,l as a,m as n,r as c,h as t,c as f,b as i,E as s,B as je}from"./index-a01aa152.js";function Ne(Be){let m,$,q,b,g,z,v,U,ee,te,k,le,A,_,ie,D,y,se,J,u,F,oe,ae,M,ne,re,R,ce,T,E,pe,B,h,fe,O,d,ue,G,j,me,K,w,ve,N,C,be,Q,I,_e,V,S,ye,W,P,Ee,X,x,he,Y,H,de;return{c(){m=o("h1"),$=r("Separate Constructing a System from Using It"),q=p(),b=o("h2"),g=r("separate processes:"),z=p(),v=o("ul"),U=o("li"),ee=r("startup: construction / wiring"),te=p(),k=o("li"),le=r("runtime: user-manipulation of the process"),A=p(),_=o("p"),ie=r("avoid small conveniences which mix concerns; construction is a concern, it should be the single concern of a single class"),D=p(),y=o("h1"),se=r("Separation of Main"),J=p(),u=o("ol"),F=o("li"),oe=r("main function builds all objects necessary for the system"),ae=p(),M=o("li"),ne=r("main passes objects to application"),re=p(),R=o("li"),ce=r("application uses already-initialized objects"),T=p(),E=o("h1"),pe=r("Factories"),B=p(),h=o("p"),fe=r("if you don’t know when to build an object, but will need to build one eventually, use a Factory"),O=p(),d=o("h1"),ue=r("Dependency Injection"),G=p(),j=o("p"),me=r("Inversion of Control; delegate responsibilities to other, dedicated objects"),K=p(),w=o("p"),ve=r("Injecting dependencies via the controller guarantees the object shares no part of dependency management"),N=p(),C=o("h1"),be=r("Scaling Up"),Q=p(),I=o("p"),_e=r("Systems can scale cleanly only if their concerns are well-separated."),V=p(),S=o("h1"),ye=r("Cross-Cutting Concerns"),W=p(),P=o("p"),Ee=r("common behaviors across multiple objects"),X=p(),x=o("h1"),he=r("Java Proxies, Aspect Programming, and Testing, etc."),Y=p(),H=o("p"),de=r("facilitate testing however possible: Reduce dependencies on concrete implementations wherever possible; rely on plain old objects or similar as much as possible in order to facilitate testing")},l(e){m=a(e,"H1",{});var l=n(m);$=c(l,"Separate Constructing a System from Using It"),l.forEach(t),q=f(e),b=a(e,"H2",{});var we=n(b);g=c(we,"separate processes:"),we.forEach(t),z=f(e),v=a(e,"UL",{});var Z=n(v);U=a(Z,"LI",{});var Ce=n(U);ee=c(Ce,"startup: construction / wiring"),Ce.forEach(t),te=f(Z),k=a(Z,"LI",{});var Ie=n(k);le=c(Ie,"runtime: user-manipulation of the process"),Ie.forEach(t),Z.forEach(t),A=f(e),_=a(e,"P",{});var Se=n(_);ie=c(Se,"avoid small conveniences which mix concerns; construction is a concern, it should be the single concern of a single class"),Se.forEach(t),D=f(e),y=a(e,"H1",{});var Pe=n(y);se=c(Pe,"Separation of Main"),Pe.forEach(t),J=f(e),u=a(e,"OL",{});var L=n(u);F=a(L,"LI",{});var xe=n(F);oe=c(xe,"main function builds all objects necessary for the system"),xe.forEach(t),ae=f(L),M=a(L,"LI",{});var He=n(M);ne=c(He,"main passes objects to application"),He.forEach(t),re=f(L),R=a(L,"LI",{});var Le=n(R);ce=c(Le,"application uses already-initialized objects"),Le.forEach(t),L.forEach(t),T=f(e),E=a(e,"H1",{});var Ue=n(E);pe=c(Ue,"Factories"),Ue.forEach(t),B=f(e),h=a(e,"P",{});var ke=n(h);fe=c(ke,"if you don’t know when to build an object, but will need to build one eventually, use a Factory"),ke.forEach(t),O=f(e),d=a(e,"H1",{});var Fe=n(d);ue=c(Fe,"Dependency Injection"),Fe.forEach(t),G=f(e),j=a(e,"P",{});var Me=n(j);me=c(Me,"Inversion of Control; delegate responsibilities to other, dedicated objects"),Me.forEach(t),K=f(e),w=a(e,"P",{});var Re=n(w);ve=c(Re,"Injecting dependencies via the controller guarantees the object shares no part of dependency management"),Re.forEach(t),N=f(e),C=a(e,"H1",{});var qe=n(C);be=c(qe,"Scaling Up"),qe.forEach(t),Q=f(e),I=a(e,"P",{});var ze=n(I);_e=c(ze,"Systems can scale cleanly only if their concerns are well-separated."),ze.forEach(t),V=f(e),S=a(e,"H1",{});var Ae=n(S);ye=c(Ae,"Cross-Cutting Concerns"),Ae.forEach(t),W=f(e),P=a(e,"P",{});var De=n(P);Ee=c(De,"common behaviors across multiple objects"),De.forEach(t),X=f(e),x=a(e,"H1",{});var Je=n(x);he=c(Je,"Java Proxies, Aspect Programming, and Testing, etc."),Je.forEach(t),Y=f(e),H=a(e,"P",{});var Te=n(H);de=c(Te,"facilitate testing however possible: Reduce dependencies on concrete implementations wherever possible; rely on plain old objects or similar as much as possible in order to facilitate testing"),Te.forEach(t)},m(e,l){i(e,m,l),s(m,$),i(e,q,l),i(e,b,l),s(b,g),i(e,z,l),i(e,v,l),s(v,U),s(U,ee),s(v,te),s(v,k),s(k,le),i(e,A,l),i(e,_,l),s(_,ie),i(e,D,l),i(e,y,l),s(y,se),i(e,J,l),i(e,u,l),s(u,F),s(F,oe),s(u,ae),s(u,M),s(M,ne),s(u,re),s(u,R),s(R,ce),i(e,T,l),i(e,E,l),s(E,pe),i(e,B,l),i(e,h,l),s(h,fe),i(e,O,l),i(e,d,l),s(d,ue),i(e,G,l),i(e,j,l),s(j,me),i(e,K,l),i(e,w,l),s(w,ve),i(e,N,l),i(e,C,l),s(C,be),i(e,Q,l),i(e,I,l),s(I,_e),i(e,V,l),i(e,S,l),s(S,ye),i(e,W,l),i(e,P,l),s(P,Ee),i(e,X,l),i(e,x,l),s(x,he),i(e,Y,l),i(e,H,l),s(H,de)},p:je,i:je,o:je,d(e){e&&t(m),e&&t(q),e&&t(b),e&&t(z),e&&t(v),e&&t(A),e&&t(_),e&&t(D),e&&t(y),e&&t(J),e&&t(u),e&&t(T),e&&t(E),e&&t(B),e&&t(h),e&&t(O),e&&t(d),e&&t(G),e&&t(j),e&&t(K),e&&t(w),e&&t(N),e&&t(C),e&&t(Q),e&&t(I),e&&t(V),e&&t(S),e&&t(W),e&&t(P),e&&t(X),e&&t(x),e&&t(Y),e&&t(H)}}}const Ve={created_at:"2022-12-10 21:36:28 -0500",updated_at:"2022-12-10 21:36:28 -0500",tags:["programming:architecture","author:Robert C. Martin","book:Clean Code"]};class We extends Oe{constructor(m){super(),Ge(this,m,null,Ne,Ke,{})}}export{We as default,Ve as metadata};
